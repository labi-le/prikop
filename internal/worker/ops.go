package worker

import (
	"bytes"
	"fmt"
	"os/exec"
	"prikop/internal/model"
	"strings"
	"syscall"
)

// SetupIptables applies rules based on target group
func SetupIptables(group string) error {
	// Flush previous rules
	_ = exec.Command("iptables", "-F", "OUTPUT").Run()

	// Direct execution implies waiting, no need to handle output/error elaborately for flush
	// Universal catch-all rules
	// TCP
	argsTCP := []string{"-I", "OUTPUT", "-p", "tcp", "-m", "multiport", "--dports", "80,443", "-j", "NFQUEUE", "--queue-num", model.QueueNum, "--queue-bypass"}
	if out, err := exec.Command("iptables", argsTCP...).CombinedOutput(); err != nil {
		return fmt.Errorf("tcp rule: %s", out)
	}
	// UDP
	argsUDP := []string{"-I", "OUTPUT", "-p", "udp", "-m", "multiport", "--dports", "443,50000:65535", "-j", "NFQUEUE", "--queue-num", model.QueueNum, "--queue-bypass"}
	if out, err := exec.Command("iptables", argsUDP...).CombinedOutput(); err != nil {
		return fmt.Errorf("udp rule: %s", out)
	}
	return nil
}

// Cleanup removes processes and flushes firewall
func Cleanup() {
	_ = exec.Command("pkill", "-9", "nfqws").Run()
	_ = exec.Command("iptables", "-F", "OUTPUT").Run()
	_ = exec.Command("iptables", "-F", "INPUT").Run()
}

// StartNFQWS executes the nfqws binary directly without shell
func StartNFQWS(argsStr string) (*exec.Cmd, *bytes.Buffer) {
	// Basic field splitting effectively handles the space-separated arguments generated by Strategy.ToArgs()
	// Since filenames in ToArgs don't contain spaces (based on observed grammar), this is safe and faster/more secure than sh -c
	args := strings.Fields(argsStr)

	// Prepend strict args
	finalArgs := append([]string{"--qnum=" + model.QueueNum}, args...)

	cmd := exec.Command("/usr/bin/nfqws", finalArgs...)

	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out
	// Setpgid creates a new process group, useful for killing the whole tree if needed
	cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}

	if err := cmd.Start(); err != nil {
		return nil, nil
	}
	return cmd, &out
}

// KillCmd force kills the process
func KillCmd(cmd *exec.Cmd) {
	if cmd != nil && cmd.Process != nil {
		// Ignore error if process already dead
		_ = syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)
		// Wait releases resources (zombies)
		_ = cmd.Wait()
	}
}
